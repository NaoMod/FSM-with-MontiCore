/* generated from model FSM */
/* generated by template core.Class*/

/* (c) https://github.com/MontiCore/monticore */
package fsm;

/* generated by template core.Imports*/

import java.util.*;
import java.util.function.*;
import java.util.stream.Stream;
import de.se_rwth.commons.logging.Log;
import fsm._ast.ASTFSM;
import fsm._cocos.FSMCoCoChecker;
import fsm._cocos.hwc.FSMHasFinalStateCoCo;
import fsm._cocos.hwc.FSMHasUniqueInitialStateCoCo;
import fsm._cocos.hwc.StateHasTransitionsWithUniqueInputCoCo;
import fsm._cocos.hwc.StatesHaveUniqueNamesCoCo;
import fsm._cocos.hwc.TransitionReferencesExistingStateCoCo;
import fsm._symboltable.IFSMArtifactScope;
import fsm.interpreter.Interpreter;
import de.monticore.ast.ASTNode;
import de.monticore.ast.Comment;
import de.se_rwth.commons.SourcePosition;
import de.monticore.symboltable.*;
import de.monticore.ast.ASTCNode;


 public  class FSMCLI  {



    /* generated by template core.Method*/
 public  static  void main (String[] args)

 {
      /* generated by template _cli.Main*/


 FSMCLI cli = new  FSMCLI();
   cli.run(args);

}

    /* generated by template core.Method*/
 public  void run (String[] args)

 {
      /* generated by template _cli.Run*/

init();
org.apache.commons.cli.Options options = initOptions();
try{
    //create CLI Parser and parse input options from commandline
    org.apache.commons.cli.CommandLineParser cliparser = new org.apache.commons.cli.DefaultParser();
    org.apache.commons.cli.CommandLine cmd = cliparser.parse(options,args);

    //help: when --help
    if(cmd.hasOption("h")){
        printHelp(options);
    //do not continue, when help is printed.
        return;
    }
    //version: when --version
    else if(cmd.hasOption("v")){
        printVersion();
        //do not continue when help is printed
        return;
    }

    if (cmd.getArgList().size()==0) {
      Log.error("The path to an FSM must be passed as an argument");
      return;
    }
    
    ASTFSM fsm = parse(cmd.getArgs()[0]);
    System.out.println("Model parsed successfully.\n");
    
    createSymbolTable(fsm);
    
    // Run cocos when c option is present
    if (cmd.hasOption("c")) {
    	runDefaultCoCos(fsm);
    }
    
    // Launch the interpreter
    Interpreter interpreter = new Interpreter(fsm);
    interpreter.interpret();

}catch (org.apache.commons.cli.ParseException e) {
   // e.getMessage displays the incorrect input-parameters
   Log.error("0xA5C06x37014 Could not process FSMCLI parameters: " + e.getMessage());
 }
}

    /* generated by template core.Method*/
 public  fsm._ast.ASTFSM parse (String model)

 {
      /* generated by template _cli.Parser*/



try {
      fsm._parser.FSMParser parser = fsm.FSMMill.parser() ;
      Optional<fsm._ast.ASTFSM> optAst = parser.parse(model);

      if (!parser.hasErrors() && optAst.isPresent()) {
        return optAst.get();
      }
      Log.error("0xA1050x18563 Model could not be parsed.");
    }
    catch (NullPointerException | java.io.IOException e) {
      Log.error("0xA1051x35278 Failed to parse " + model, e);
    }
    // should never be reached (unless failquick is off)
    return null;

}

    /* generated by template core.Method*/
 public  void init ()

 {
      /* generated by template _cli.Init*/

// initialize logging with standard logging
Log.init();
fsm.FSMMill.init();

}

    /* generated by template core.Method*/
 public  void prettyPrint (fsm._ast.ASTFSM ast,String file)

 {
      Log.warn("0xA1052x14561 PrettyPrinting is not implemented yet.");
}

    /* generated by template core.Method*/
 public  void print (String content,String path)

 {
      /* generated by template _cli.Print*/

// print to stdout or file
  if (path.isEmpty()) {
    System.out.println(content);
  } else {
    java.io.File f = new java.io.File(path);
    // create directories (logs error otherwise)
    f.getAbsoluteFile().getParentFile().mkdirs();
    java.io.FileWriter writer;
    try {
      writer = new java.io.FileWriter(f);
      writer.write(content);
      writer.close();
    } catch (java.io.IOException e) {
      Log.error("0xA7105x45964 Could not write to file " + f.getAbsolutePath());
    }
  }
}

    /* generated by template core.Method*/
 public  void printHelp (org.apache.commons.cli.Options options)

 {
      /* generated by template _cli.PrintHelp*/


  org.apache.commons.cli.HelpFormatter formatter = new org.apache.commons.cli.HelpFormatter();
  formatter.setWidth(80);
  formatter.printHelp("FSMCLI", options);

}

    /* generated by template core.Method*/
 public  void printVersion ()

 {
      /* generated by template _cli.PrintVersion*/


// Get version string from Metadata and print

final String buildDate = "2021-12-06";
final String toolName = "FSMTool";
final String mcVersion = "7.3.0-SNAPSHOT";

java.util.Properties properties = new java.util.Properties();

try {
  java.io.BufferedInputStream stream = new java.io.BufferedInputStream(getClass().getResourceAsStream("/buildInfo.properties"));
  properties.load(stream);
  stream.close();
} catch(java.io.IOException e) {
  // BuildInfo not present
}

String toolVersion = properties.getProperty("version");
if (toolVersion == null) toolVersion = mcVersion;

System.out.println(toolName +
    ", version " + toolVersion +
    ", build date " + buildDate +
    ", based on MontiCore version " + mcVersion);
}

    /* generated by template core.Method*/
 public  void report (fsm._ast.ASTFSM ast,String path)

 {
      Log.warn("0xA1058x59716 Reports are not implemented yet.");
}

    /* generated by template core.Method*/
 public  void runDefaultCoCos (fsm._ast.ASTFSM ast)

 {
	    System.out.println("Running default cocos...");
      FSMCoCoChecker checker = new FSMCoCoChecker();
      checker.addCoCo(new FSMHasFinalStateCoCo());
      checker.addCoCo(new FSMHasUniqueInitialStateCoCo());
      checker.addCoCo(new StateHasTransitionsWithUniqueInputCoCo());
      checker.addCoCo(new StatesHaveUniqueNamesCoCo());
      checker.addCoCo(new TransitionReferencesExistingStateCoCo());
      checker.checkAll(ast);
      System.out.println("Cocos passed.\n");
}

    /* generated by template core.Method*/
 public  void runAdditionalCoCos (fsm._ast.ASTFSM ast)

 {
      Log.warn("0xA1062x36841 additional CoCos are not implemented yet.");
}

    /* generated by template core.Method*/
 public  void storeSymbols (fsm._symboltable.IFSMArtifactScope scope,String path)

 {
      /* generated by template _cli.StoreSymbols*/

fsm._symboltable.FSMSymbols2Json symbols2Json = new fsm._symboltable.FSMSymbols2Json();
    symbols2Json.store(scope, path);

}

    /* generated by template core.Method*/
 public  org.apache.commons.cli.Options initOptions ()

 {
      /* generated by template _cli.InitOptions*/
org.apache.commons.cli.Options options = new org.apache.commons.cli.Options();
options = addStandardOptions(options);
options = addAdditionalOptions(options);
return options;
}

    /* generated by template core.Method*/
 public  org.apache.commons.cli.Options addStandardOptions (org.apache.commons.cli.Options options)

 {
      /* generated by template _cli.AddStandardOptions*/
//help
options.addOption(org.apache.commons.cli.Option.builder("h")
    .longOpt("help")
    .desc("Prints this help dialog")
    .build());

//version
options.addOption(org.apache.commons.cli.Option.builder("v")
    .longOpt("version")
    .desc("Prints version information")
    .build());

//parse input file
options.addOption(org.apache.commons.cli.Option.builder("i")
    .longOpt("input")
    .argName("file")
    .hasArg()
    .desc("Reads the source file (mandatory) and parses the contents")
    .build());

//pretty print runner
options.addOption(org.apache.commons.cli.Option.builder("pp")
    .longOpt("prettyprint")
    .argName("file")
    .optionalArg(true)
    .numberOfArgs(1)
    .desc("Prints the AST to stdout or the specified file (optional)")
    .build());

// pretty print SC
options.addOption(org.apache.commons.cli.Option.builder("s")
    .longOpt("symboltable")
    .argName("file")
    .hasArg()
    .desc("Serialized the Symbol table of the given artifact.")
    .build());

//reports about the runner
options.addOption(org.apache.commons.cli.Option.builder("r")
    .longOpt("report")
    .argName("dir")
    .hasArg(true)
    .desc("Prints reports of the artifact to the specified directory.")
    .build());

// model paths
options.addOption(org.apache.commons.cli.Option.builder("path")
    .hasArgs()
    .desc("Sets the artifact path for imported symbols, space separated.")
    .build());

//model paths
options.addOption(org.apache.commons.cli.Option.builder("c")
	.longOpt("check")
	.desc("Checks the default context conditions.")
	.build());

return options;

}

    /* generated by template core.Method*/
 public  org.apache.commons.cli.Options addAdditionalOptions (org.apache.commons.cli.Options options)

 {
      /* generated by template _cli.AddAdditionalOptions*/

return options;

}

    /* generated by template core.Method*/
 public  fsm._symboltable.IFSMArtifactScope createSymbolTable (fsm._ast.ASTFSM node)

 {
      /* generated by template _cli.SymbolTable*/


fsm._symboltable.FSMScopesGenitorDelegator genitor = fsm.FSMMill.scopesGenitorDelegator();
fsm._symboltable.IFSMArtifactScope symTab = genitor.createFromAST(node);
return symTab;
}

    /* generated by template core.Method*/
 public  void completeSymbolTable (fsm._ast.ASTFSM node)

 {
      Log.warn("0xA1158x69792 This symbol table phase is not implemented yet.");
}

}
