/* generated from model FSM */
/* generated by template core.Interface*/

/* (c) https://github.com/MontiCore/monticore */
package fsm._symboltable;

/* generated by template core.Imports*/

import java.util.*;
import java.util.function.*;
import java.util.stream.Stream;
import de.se_rwth.commons.logging.Log;
import de.monticore.ast.ASTNode;
import de.monticore.ast.Comment;
import de.se_rwth.commons.SourcePosition;
import de.monticore.symboltable.*;


 public  interface IFSMScope extends de.monticore.literals.mccommonliterals._symboltable.IMCCommonLiteralsScope  { 


  /* generated by template core.Method*/
 abstract  public  boolean isStateSymbolsAlreadyResolved ()

;
  /* generated by template core.Method*/
 abstract  public  void setStateSymbolsAlreadyResolved (boolean symbolAlreadyResolved)

;
  default /* generated by template core.Method*/
 public  Optional<fsm._symboltable.StateSymbol> resolveState (String name)

 {
      /* generated by template _symboltable.iscope.ResolveDelegate*/

  return getResolvedOrThrowException(resolveStateMany(name ));
}

  default /* generated by template core.Method*/
 public  Optional<fsm._symboltable.StateSymbol> resolveState (String name,de.monticore.symboltable.modifiers.AccessModifier modifier)

 {
      /* generated by template _symboltable.iscope.ResolveDelegate*/

  return getResolvedOrThrowException(resolveStateMany(name, modifier ));
}

  default /* generated by template core.Method*/
 public  Optional<fsm._symboltable.StateSymbol> resolveState (String name,de.monticore.symboltable.modifiers.AccessModifier modifier,java.util.function.Predicate<fsm._symboltable.StateSymbol> predicate)

 {
      /* generated by template _symboltable.iscope.ResolveDelegate*/

  return getResolvedOrThrowException(resolveStateMany(name, modifier, predicate ));
}

  default /* generated by template core.Method*/
 public  Optional<fsm._symboltable.StateSymbol> resolveState (boolean foundSymbols,String name,de.monticore.symboltable.modifiers.AccessModifier modifier)

 {
      /* generated by template _symboltable.iscope.ResolveDelegate*/

  return getResolvedOrThrowException(resolveStateMany(foundSymbols, name, modifier ));
}

  default /* generated by template core.Method*/
 public  Optional<fsm._symboltable.StateSymbol> resolveStateDown (String name)

 {
      /* generated by template _symboltable.iscope.ResolveDelegate*/

  return getResolvedOrThrowException(resolveStateDownMany(name ));
}

  default /* generated by template core.Method*/
 public  Optional<fsm._symboltable.StateSymbol> resolveStateDown (String name,de.monticore.symboltable.modifiers.AccessModifier modifier)

 {
      /* generated by template _symboltable.iscope.ResolveDelegate*/

  return getResolvedOrThrowException(resolveStateDownMany(name, modifier ));
}

  default /* generated by template core.Method*/
 public  Optional<fsm._symboltable.StateSymbol> resolveStateDown (String name,de.monticore.symboltable.modifiers.AccessModifier modifier,java.util.function.Predicate<fsm._symboltable.StateSymbol> predicate)

 {
      /* generated by template _symboltable.iscope.ResolveDelegate*/

  return getResolvedOrThrowException(resolveStateDownMany(name, modifier, predicate ));
}

  default /* generated by template core.Method*/
 public  List<fsm._symboltable.StateSymbol> resolveStateDownMany (String name)

 {
      return this.resolveStateDownMany(false,name,de.monticore.symboltable.modifiers.AccessModifier.ALL_INCLUSION,x -> true);
}

  default /* generated by template core.Method*/
 public  List<fsm._symboltable.StateSymbol> resolveStateDownMany (String name,de.monticore.symboltable.modifiers.AccessModifier modifier)

 {
      return this.resolveStateDownMany(false,name,modifier,x -> true);
}

  default /* generated by template core.Method*/
 public  List<fsm._symboltable.StateSymbol> resolveStateDownMany (String name,de.monticore.symboltable.modifiers.AccessModifier modifier,java.util.function.Predicate<fsm._symboltable.StateSymbol> predicate)

 {
      return this.resolveStateDownMany(false,name,modifier,predicate);
}

  default /* generated by template core.Method*/
 public  List<fsm._symboltable.StateSymbol> resolveStateDownMany (boolean foundSymbols,String name,de.monticore.symboltable.modifiers.AccessModifier modifier,java.util.function.Predicate<fsm._symboltable.StateSymbol> predicate)

 {
      /* generated by template _symboltable.iscope.ResolveDownMany*/

  // skip resolution of the symbol, if the symbol has already been resolved in this scope instance
  // during the current execution of the resolution algorithm
  if (isStateSymbolsAlreadyResolved()) {
    return new ArrayList<>();
  }

  // (1) resolve symbol locally. During this, the 'already resolved' flag is set to true,
  // to prevent resolving cycles caused by cyclic symbol adapters
  setStateSymbolsAlreadyResolved(true);
  final List<fsm._symboltable.StateSymbol> resolvedSymbols = this.resolveStateLocallyMany(foundSymbols, name, modifier, predicate);
  foundSymbols = foundSymbols || resolvedSymbols.size() > 0;
  setStateSymbolsAlreadyResolved(false);

  final String resolveCall = "resolveDownMany(\"" + name + "\", \"" + "StateSymbol"
    + "\") in scope \"" + (isPresentName() ? getName() : "") + "\"";
  Log.trace("START " + resolveCall + ". Found #" + resolvedSymbols.size() + " (local)", "");
  // If no matching symbols have been found...
  if (resolvedSymbols.isEmpty()) {
    // (2) Continue search in sub scopes and ...
    for (fsm._symboltable.IFSMScope subScope : getSubScopes()) {
      final List<fsm._symboltable.StateSymbol> resolvedFromSub = subScope
        .continueAsStateSubScope(foundSymbols, name, modifier, predicate);
      foundSymbols = foundSymbols || resolvedFromSub.size() > 0;
      // (3) unify results
      resolvedSymbols.addAll(resolvedFromSub);
    }
  }
  Log.trace("END " + resolveCall + ". Found #" + resolvedSymbols.size(), "");
  setStateSymbolsAlreadyResolved(false);
  return resolvedSymbols;
}

  default /* generated by template core.Method*/
 public  Optional<fsm._symboltable.StateSymbol> resolveStateLocally (String name)

 {
       return getResolvedOrThrowException(this.resolveStateLocallyMany(false,name,de.monticore.symboltable.modifiers.AccessModifier.ALL_INCLUSION,x -> true));
}

  default /* generated by template core.Method*/
 public  List<fsm._symboltable.StateSymbol> resolveStateLocallyMany (boolean foundSymbols,String name,de.monticore.symboltable.modifiers.AccessModifier modifier,java.util.function.Predicate<fsm._symboltable.StateSymbol> predicate)

 {
      /* generated by template _symboltable.iscope.ResolveManyLocally*/

  final List<fsm._symboltable.StateSymbol> resolvedSymbols = new ArrayList<>();

  try {
    Optional<fsm._symboltable.StateSymbol> resolvedSymbol = filterState(name, getStateSymbols());
    if (resolvedSymbol.isPresent()) {
      resolvedSymbols.add(resolvedSymbol.get());
    }
  } catch (de.monticore.symboltable.resolving.ResolvedSeveralEntriesForSymbolException e) {
    resolvedSymbols.addAll(e.getSymbols());
  }

  // add all symbols of sub kinds of the current kind
  resolvedSymbols.addAll(resolveStateSubKinds(foundSymbols, name, modifier, predicate));

  // filter out symbols that are not included within the access modifier
  List<fsm._symboltable.StateSymbol> filteredSymbols = filterSymbolsByAccessModifier(modifier, resolvedSymbols);
  filteredSymbols = new ArrayList<>(filteredSymbols.stream().filter(predicate).collect(java.util.stream.Collectors.toList()));

  // if no symbols found try to find adapted one
  if (filteredSymbols.isEmpty()) {
    filteredSymbols.addAll(resolveAdaptedStateLocallyMany(foundSymbols, name, modifier, predicate));
    filteredSymbols = filterSymbolsByAccessModifier(modifier, filteredSymbols);
    filteredSymbols = new ArrayList<>(filteredSymbols.stream().filter(predicate).collect(java.util.stream.Collectors.toList()));
  }
  return filteredSymbols;
}

  /* generated by template core.Method*/
 abstract  public  List<fsm._symboltable.StateSymbol> resolveStateSubKinds (boolean foundSymbols,String name,de.monticore.symboltable.modifiers.AccessModifier modifier,java.util.function.Predicate<fsm._symboltable.StateSymbol> predicate)

;
  default /* generated by template core.Method*/
 public  List<fsm._symboltable.StateSymbol> resolveStateMany (String name)

 {
      return this.resolveStateMany(name,de.monticore.symboltable.modifiers.AccessModifier.ALL_INCLUSION);
}

  default /* generated by template core.Method*/
 public  List<fsm._symboltable.StateSymbol> resolveStateMany (String name,de.monticore.symboltable.modifiers.AccessModifier modifier)

 {
      return this.resolveStateMany(name,modifier,x -> true);
}

  default /* generated by template core.Method*/
 public  List<fsm._symboltable.StateSymbol> resolveStateMany (String name,de.monticore.symboltable.modifiers.AccessModifier modifier,java.util.function.Predicate<fsm._symboltable.StateSymbol> predicate)

 {
      return this.resolveStateMany(false,name,modifier,predicate);
}

  default /* generated by template core.Method*/
 public  List<fsm._symboltable.StateSymbol> resolveStateMany (String name,java.util.function.Predicate<fsm._symboltable.StateSymbol> predicate)

 {
      return this.resolveStateMany(false,name,de.monticore.symboltable.modifiers.AccessModifier.ALL_INCLUSION,predicate);
}

  default /* generated by template core.Method*/
 public  List<fsm._symboltable.StateSymbol> resolveStateMany (boolean foundSymbols,String name,de.monticore.symboltable.modifiers.AccessModifier modifier)

 {
      return this.resolveStateMany(foundSymbols,name,modifier,x -> true);
}

  default /* generated by template core.Method*/
 public  List<fsm._symboltable.StateSymbol> resolveStateMany (boolean foundSymbols,String name,de.monticore.symboltable.modifiers.AccessModifier modifier,java.util.function.Predicate<fsm._symboltable.StateSymbol> predicate)

 {
      /* generated by template _symboltable.iscope.ResolveMany4IScope*/

  // skip resolution of the symbol, if the symbol has already been resolved in this scope instance
  // during the current execution of the resolution algorithm
  if (isStateSymbolsAlreadyResolved()) {
    return new ArrayList<>();
  }

  // (1) resolve symbol locally. During this, the 'already resolved' flag is set to true,
  // to prevent resolving cycles caused by cyclic symbol adapters
  setStateSymbolsAlreadyResolved(true);
  final List<fsm._symboltable.StateSymbol> resolvedSymbols = this.resolveStateLocallyMany(foundSymbols, name, modifier, predicate);
  foundSymbols = foundSymbols | resolvedSymbols.size() > 0;
  setStateSymbolsAlreadyResolved(false);

  final String resolveCall = "resolveMany(\"" + name + "\", \"" + "StateSymbol"
  + "\") in scope \"" + (isPresentName() ? getName() : "") + "\"";
  Log.trace("START " + resolveCall + ". Found #" + resolvedSymbols.size() + " (local)", "");

  // (2) continue with enclosingScope, if either no symbol has been found yet or this scope is non-shadowing
  final List<fsm._symboltable.StateSymbol> resolvedFromEnclosing = continueStateWithEnclosingScope(foundSymbols, name, modifier, predicate);

  // (3) unify results
  resolvedSymbols.addAll(resolvedFromEnclosing);
  Log.trace("END " + resolveCall + ". Found #" + resolvedSymbols.size(), "");

  return resolvedSymbols;
}

  default /* generated by template core.Method*/
 public  List<fsm._symboltable.StateSymbol> resolveAdaptedStateLocallyMany (boolean foundSymbols,String name,de.monticore.symboltable.modifiers.AccessModifier modifier,java.util.function.Predicate<fsm._symboltable.StateSymbol> predicate)

 {
      return new java.util.ArrayList<>();
}

  default /* generated by template core.Method*/
 public  Optional<fsm._symboltable.StateSymbol> filterState (String name,com.google.common.collect.LinkedListMultimap<String,fsm._symboltable.StateSymbol> symbols)

 {
      /* generated by template _symboltable.iscope.Filter*/

  final Set<fsm._symboltable.StateSymbol> resolvedSymbols = new LinkedHashSet<>();

  final String simpleName = de.se_rwth.commons.Names.getSimpleName(name);

  if (symbols.containsKey(simpleName)) {
    for (fsm._symboltable.StateSymbol symbol : symbols.get(simpleName)) {
      if (symbol.getName().equals(name) || symbol.getFullName().equals(name)) {
        resolvedSymbols.add(symbol);
      }
    }
  }

  return getResolvedOrThrowException(resolvedSymbols);
}

  default /* generated by template core.Method*/
 public  List<fsm._symboltable.StateSymbol> continueStateWithEnclosingScope (boolean foundSymbols,String name,de.monticore.symboltable.modifiers.AccessModifier modifier,java.util.function.Predicate<fsm._symboltable.StateSymbol> predicate)

 {
      /* generated by template _symboltable.iscope.ContinueWithEnclosingScope4IScope*/

if (checkIfContinueWithEnclosingScope(foundSymbols) && (getEnclosingScope() != null)) {
    return getEnclosingScope().resolveStateMany(foundSymbols, name, modifier, predicate);
  }
  return new ArrayList<>();
}

  default /* generated by template core.Method*/
 public  List<fsm._symboltable.StateSymbol> continueAsStateSubScope (boolean foundSymbols,String name,de.monticore.symboltable.modifiers.AccessModifier modifier,java.util.function.Predicate<fsm._symboltable.StateSymbol> predicate)

 {
      /* generated by template _symboltable.iscope.ContinueAsSubScope*/

  List<StateSymbol> resultList = new ArrayList<>();
  setStateSymbolsAlreadyResolved(false);
  if (checkIfContinueAsSubScope(name)) {
    for(String remainingSymbolName: getRemainingNameForResolveDown(name)) {
      resultList.addAll(this.resolveStateDownMany(foundSymbols, remainingSymbolName, modifier, predicate));
    }
  }
  return resultList;
}

  /* generated by template core.Method*/
 abstract  public  com.google.common.collect.LinkedListMultimap<String,fsm._symboltable.StateSymbol> getStateSymbols ()

;
  default /* generated by template core.Method*/
 public  List<fsm._symboltable.StateSymbol> getLocalStateSymbols ()

 {
      return getStateSymbols().values();
}

  /* generated by template core.Method*/
 abstract  public  void add (fsm._symboltable.StateSymbol symbol)

;
  /* generated by template core.Method*/
 abstract  public  void remove (fsm._symboltable.StateSymbol symbol)

;
  /* generated by template core.Method*/
 abstract  public  List<? extends IFSMScope> getSubScopes ()

;
  default /* generated by template core.Method*/
 public  void addSubScope (IFSMScope subScope)

 {
      Log.error("0xA7014x54981 The method \"addSubScope\" of interface \"IFSMScope\" is not implemented.");
}

  default /* generated by template core.Method*/
 public  void removeSubScope (IFSMScope subScope)

 {
      Log.error("0xA7013x90529 The method \"removeSubScope\" of interface \"IFSMScope\" is not implemented.");
}

  /* generated by template core.Method*/
 abstract  public  IFSMScope getEnclosingScope ()

;
  /* generated by template core.Method*/
 abstract  public  void setEnclosingScope (IFSMScope enclosingScope)

;
  /* generated by template core.Method*/
 abstract  public  void accept (fsm._visitor.FSMTraverser visitor)

;
  default /* generated by template core.Method*/
 public  int getSymbolsSize ()

 {
      /* generated by template _symboltable.iscope.GetSymbolSize*/


Set<ISymbol> allSymbols = new HashSet<>();
    allSymbols.addAll(getStateSymbols().values());
return allSymbols.size();
}

}
